-- LocalScript (StarterPlayerScripts)
-- Enhanced Multi-Universal Aim Assist [ULTIMATE EDITION + TRIGGERBOT]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Teams = game:GetService("Teams")

-- Only run on mobile
--if not UserInputService.TouchEnabled then
--	return
--end

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character, humanoid, hrp

local aimAssistEnabled = false
local advancedAimEnabled = false
local espEnabled = false
local triggerbotEnabled = false
local currentTarget = nil
local FOV_RADIUS = 150

local function setupCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- GUI
local gui = Instance.new("ScreenGui")
gui.Name = "AimAssistUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- Minimized Button
local miniBtn = Instance.new("TextButton")
miniBtn.Size = UDim2.new(0, 50, 0, 50)
miniBtn.Position = UDim2.new(0.85, -50, 0.3, 0)
miniBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
miniBtn.BorderSizePixel = 0
miniBtn.Font = Enum.Font.GothamBold
miniBtn.TextSize = 20
miniBtn.TextColor3 = Color3.new(1, 1, 1)
miniBtn.Text = "+"
miniBtn.Visible = false
miniBtn.ZIndex = 10
miniBtn.Active = true
miniBtn.Parent = gui

local miniBtnCorner = Instance.new("UICorner")
miniBtnCorner.CornerRadius = UDim.new(0.5, 0)
miniBtnCorner.Parent = miniBtn

local miniLabel = Instance.new("TextLabel")
miniLabel.Size = UDim2.new(1, 0, 0, 15)
miniLabel.Position = UDim2.new(0, 0, 1, 2)
miniLabel.BackgroundTransparency = 1
miniLabel.Text = "AIM"
miniLabel.Font = Enum.Font.GothamBold
miniLabel.TextSize = 10
miniLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
miniLabel.Parent = miniBtn

-- Main Container (ENLARGED FOR TRIGGERBOT)
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 160, 0, 370)
mainFrame.Position = UDim2.new(0.85, -160, 0.22, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Active = false
mainFrame.Parent = gui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 12)
mainCorner.Parent = mainFrame

-- Drag Handle
local dragHandle = Instance.new("Frame")
dragHandle.Size = UDim2.new(1, 0, 0, 35)
dragHandle.BackgroundTransparency = 1
dragHandle.Active = true
dragHandle.Parent = mainFrame

-- Title
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -100, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "AIM ASSIST"
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = dragHandle

-- Triggerbot Settings Button (+ icon) - NEW
local triggerbotSettingsBtn = Instance.new("TextButton")
triggerbotSettingsBtn.Size = UDim2.new(0, 24, 0, 24)
triggerbotSettingsBtn.Position = UDim2.new(1, -75, 0, 5)
triggerbotSettingsBtn.Text = "+"
triggerbotSettingsBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 100)
triggerbotSettingsBtn.TextColor3 = Color3.new(1, 1, 1)
triggerbotSettingsBtn.Font = Enum.Font.GothamBold
triggerbotSettingsBtn.TextSize = 18
triggerbotSettingsBtn.ZIndex = 10
triggerbotSettingsBtn.Parent = dragHandle

local triggerbotSettingsCorner = Instance.new("UICorner")
triggerbotSettingsCorner.CornerRadius = UDim.new(0.5, 0)
triggerbotSettingsCorner.Parent = triggerbotSettingsBtn

-- Profile Selector Button (+ icon for body part selection)
local profileBtn = Instance.new("TextButton")
profileBtn.Size = UDim2.new(0, 24, 0, 24)
profileBtn.Position = UDim2.new(1, -50, 0, 5)
profileBtn.Text = "+"
profileBtn.BackgroundColor3 = Color3.fromRGB(46, 147, 216)
profileBtn.TextColor3 = Color3.new(1, 1, 1)
profileBtn.Font = Enum.Font.GothamBold
profileBtn.TextSize = 18
profileBtn.ZIndex = 10
profileBtn.Parent = dragHandle

local profileCorner = Instance.new("UICorner")
profileCorner.CornerRadius = UDim.new(0.5, 0)
profileCorner.Parent = profileBtn

-- Minimize Button
local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, 20, 0, 20)
minimizeBtn.Position = UDim2.new(1, -25, 0, 7)
minimizeBtn.Text = "-"
minimizeBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 20
minimizeBtn.ZIndex = 10
minimizeBtn.Parent = dragHandle

local minimizeCorner = Instance.new("UICorner")
minimizeCorner.CornerRadius = UDim.new(0.5, 0)
minimizeCorner.Parent = minimizeBtn

-- Status Indicator
local statusDot = Instance.new("Frame")
statusDot.Size = UDim2.new(0, 10, 0, 10)
statusDot.Position = UDim2.new(1, -15, 0, 12)
statusDot.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
statusDot.BorderSizePixel = 0
statusDot.Parent = dragHandle

local dotCorner = Instance.new("UICorner")
dotCorner.CornerRadius = UDim.new(0.5, 0)
dotCorner.Parent = statusDot

-- Triggerbot Settings Menu Container - NEW
local triggerbotMenu = Instance.new("Frame")
triggerbotMenu.Size = UDim2.new(0, 140, 0, 0)
triggerbotMenu.Position = UDim2.new(1, 5, 0, 30)
triggerbotMenu.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
triggerbotMenu.BorderSizePixel = 0
triggerbotMenu.ClipsDescendants = true
triggerbotMenu.Visible = false
triggerbotMenu.ZIndex = 11
triggerbotMenu.Parent = mainFrame

local triggerbotMenuCorner = Instance.new("UICorner")
triggerbotMenuCorner.CornerRadius = UDim.new(0, 8)
triggerbotMenuCorner.Parent = triggerbotMenu

-- Delay Label
local delayLabel = Instance.new("TextLabel")
delayLabel.Size = UDim2.new(1, -10, 0, 18)
delayLabel.Position = UDim2.new(0, 5, 0, 5)
delayLabel.BackgroundTransparency = 1
delayLabel.Text = "Delay: 50ms"
delayLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
delayLabel.TextSize = 11
delayLabel.Font = Enum.Font.Gotham
delayLabel.TextXAlignment = Enum.TextXAlignment.Left
delayLabel.ZIndex = 12
delayLabel.Parent = triggerbotMenu

-- Delay Slider
local delaySliderFrame = Instance.new("Frame")
delaySliderFrame.Size = UDim2.new(1, -10, 0, 6)
delaySliderFrame.Position = UDim2.new(0, 5, 0, 25)
delaySliderFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
delaySliderFrame.BorderSizePixel = 0
delaySliderFrame.ZIndex = 12
delaySliderFrame.Parent = triggerbotMenu

local delaySliderCorner = Instance.new("UICorner")
delaySliderCorner.CornerRadius = UDim.new(0.5, 0)
delaySliderCorner.Parent = delaySliderFrame

local delaySliderFill = Instance.new("Frame")
delaySliderFill.Size = UDim2.new(0.1, 0, 1, 0)
delaySliderFill.BackgroundColor3 = Color3.fromRGB(200, 50, 100)
delaySliderFill.BorderSizePixel = 0
delaySliderFill.ZIndex = 13
delaySliderFill.Parent = delaySliderFrame

local delayFillCorner = Instance.new("UICorner")
delayFillCorner.CornerRadius = UDim.new(0.5, 0)
delayFillCorner.Parent = delaySliderFill

local delaySliderKnob = Instance.new("TextButton")
delaySliderKnob.Size = UDim2.new(0, 14, 0, 14)
delaySliderKnob.Position = UDim2.new(0.1, -7, 0.5, -7)
delaySliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
delaySliderKnob.Text = ""
delaySliderKnob.ZIndex = 14
delaySliderKnob.Parent = delaySliderFrame

local delayKnobCorner = Instance.new("UICorner")
delayKnobCorner.CornerRadius = UDim.new(0.5, 0)
delayKnobCorner.Parent = delaySliderKnob

-- Hold Time Label
local holdLabel = Instance.new("TextLabel")
holdLabel.Size = UDim2.new(1, -10, 0, 18)
holdLabel.Position = UDim2.new(0, 5, 0, 40)
holdLabel.BackgroundTransparency = 1
holdLabel.Text = "Hold: 100ms"
holdLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
holdLabel.TextSize = 11
holdLabel.Font = Enum.Font.Gotham
holdLabel.TextXAlignment = Enum.TextXAlignment.Left
holdLabel.ZIndex = 12
holdLabel.Parent = triggerbotMenu

-- Hold Slider
local holdSliderFrame = Instance.new("Frame")
holdSliderFrame.Size = UDim2.new(1, -10, 0, 6)
holdSliderFrame.Position = UDim2.new(0, 5, 0, 60)
holdSliderFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
holdSliderFrame.BorderSizePixel = 0
holdSliderFrame.ZIndex = 12
holdSliderFrame.Parent = triggerbotMenu

local holdSliderCorner = Instance.new("UICorner")
holdSliderCorner.CornerRadius = UDim.new(0.5, 0)
holdSliderCorner.Parent = holdSliderFrame

local holdSliderFill = Instance.new("Frame")
holdSliderFill.Size = UDim2.new(0.2, 0, 1, 0)
holdSliderFill.BackgroundColor3 = Color3.fromRGB(200, 50, 100)
holdSliderFill.BorderSizePixel = 0
holdSliderFill.ZIndex = 13
holdSliderFill.Parent = holdSliderFrame

local holdFillCorner = Instance.new("UICorner")
holdFillCorner.CornerRadius = UDim.new(0.5, 0)
holdFillCorner.Parent = holdSliderFill

local holdSliderKnob = Instance.new("TextButton")
holdSliderKnob.Size = UDim2.new(0, 14, 0, 14)
holdSliderKnob.Position = UDim2.new(0.2, -7, 0.5, -7)
holdSliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
holdSliderKnob.Text = ""
holdSliderKnob.ZIndex = 14
holdSliderKnob.Parent = holdSliderFrame

local holdKnobCorner = Instance.new("UICorner")
holdKnobCorner.CornerRadius = UDim.new(0.5, 0)
holdKnobCorner.Parent = holdSliderKnob

-- Profile Menu Container (Body Part Selection)
local profileMenu = Instance.new("Frame")
profileMenu.Size = UDim2.new(0, 140, 0, 0)
profileMenu.Position = UDim2.new(1, 5, 0, 0)
profileMenu.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
profileMenu.BorderSizePixel = 0
profileMenu.ClipsDescendants = true
profileMenu.Visible = false
profileMenu.ZIndex = 11
profileMenu.Parent = mainFrame

local menuCorner = Instance.new("UICorner")
menuCorner.CornerRadius = UDim.new(0, 8)
menuCorner.Parent = profileMenu

-- Body Part Profiles
local bodyParts = {
	{name = "HEAD", desc = "High Risk", part = "Head", color = Color3.fromRGB(255, 80, 80)},
	{name = "NECK", desc = "Extreme", part = "Neck", color = Color3.fromRGB(255, 40, 40)},
	{name = "TORSO", desc = "Balanced", part = "Torso", color = Color3.fromRGB(80, 200, 120)},
	{name = "LEG", desc = "Safe", part = "Left Leg", color = Color3.fromRGB(100, 180, 255)}
}

local currentBodyPart = 1
local aimPart = "Head"
local bodyPartButtons = {}

for i, part in ipairs(bodyParts) do
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, -10, 0, 32)
	btn.Position = UDim2.new(0, 5, 0, 5 + (i-1) * 37)
	btn.BackgroundColor3 = part.color
	btn.BackgroundTransparency = 0.2
	btn.BorderSizePixel = 0
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 12
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Text = part.name .. " ¬∑ " .. part.desc
	btn.ZIndex = 12
	btn.Parent = profileMenu
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	-- Selection indicator
	local indicator = Instance.new("Frame")
	indicator.Size = UDim2.new(0, 3, 1, -6)
	indicator.Position = UDim2.new(0, 3, 0, 3)
	indicator.BackgroundColor3 = Color3.new(1, 1, 1)
	indicator.BorderSizePixel = 0
	indicator.Visible = (i == 1)
	indicator.ZIndex = 13
	indicator.Parent = btn
	
	local indCorner = Instance.new("UICorner")
	indCorner.CornerRadius = UDim.new(1, 0)
	indCorner.Parent = indicator
	
	bodyPartButtons[i] = {button = btn, indicator = indicator, part = part}
	
	-- Part selection
	btn.Activated:Connect(function()
		currentBodyPart = i
		aimPart = part.part
		
		-- Update indicators
		for j, data in ipairs(bodyPartButtons) do
			data.indicator.Visible = (j == i)
			TweenService:Create(data.button, TweenInfo.new(0.2), {
				BackgroundTransparency = (j == i) and 0.2 or 0.5
			}):Play()
		end
		
		-- Visual feedback
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(1, -8, 0, 32)
		}):Play()
		task.wait(0.1)
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(1, -10, 0, 32)
		}):Play()
	end)
end

-- Triggerbot menu toggle
local triggerbotMenuOpen = false
triggerbotSettingsBtn.Activated:Connect(function()
	triggerbotMenuOpen = not triggerbotMenuOpen
	
	if triggerbotMenuOpen then
		triggerbotMenu.Visible = true
		TweenService:Create(triggerbotMenu, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, 140, 0, 75)
		}):Play()
		TweenService:Create(triggerbotSettingsBtn, TweenInfo.new(0.2), {
			Rotation = 45,
			BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		}):Play()
	else
		TweenService:Create(triggerbotMenu, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 140, 0, 0)
		}):Play()
		TweenService:Create(triggerbotSettingsBtn, TweenInfo.new(0.2), {
			Rotation = 0,
			BackgroundColor3 = Color3.fromRGB(200, 50, 100)
		}):Play()
		task.wait(0.2)
		triggerbotMenu.Visible = false
	end
end)

-- Profile menu toggle
local menuOpen = false
profileBtn.Activated:Connect(function()
	menuOpen = not menuOpen
	
	if menuOpen then
		profileMenu.Visible = true
		TweenService:Create(profileMenu, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, 140, 0, 155)
		}):Play()
		TweenService:Create(profileBtn, TweenInfo.new(0.2), {
			Rotation = 45,
			BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		}):Play()
	else
		TweenService:Create(profileMenu, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 140, 0, 0)
		}):Play()
		TweenService:Create(profileBtn, TweenInfo.new(0.2), {
			Rotation = 0,
			BackgroundColor3 = Color3.fromRGB(46, 147, 216)
		}):Play()
		task.wait(0.2)
		profileMenu.Visible = false
	end
end)

-- Toggle Button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(1, -20, 0, 35)
toggleBtn.Position = UDim2.new(0, 10, 0, 45)
toggleBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
toggleBtn.Text = "DISABLED"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.TextColor3 = Color3.new(1, 1, 1)
toggleBtn.Parent = mainFrame

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleBtn

-- Advanced Aim Button
local advancedBtn = Instance.new("TextButton")
advancedBtn.Size = UDim2.new(1, -20, 0, 32)
advancedBtn.Position = UDim2.new(0, 10, 0, 88)
advancedBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
advancedBtn.Text = "üéØ Adv Aim: OFF"
advancedBtn.Font = Enum.Font.GothamBold
advancedBtn.TextSize = 12
advancedBtn.TextColor3 = Color3.new(1, 1, 1)
advancedBtn.Parent = mainFrame

local advancedCorner = Instance.new("UICorner")
advancedCorner.CornerRadius = UDim.new(0, 8)
advancedCorner.Parent = advancedBtn

-- ESP Toggle Button
local espBtn = Instance.new("TextButton")
espBtn.Size = UDim2.new(1, -20, 0, 32)
espBtn.Position = UDim2.new(0, 10, 0, 128)
espBtn.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
espBtn.Text = "üëÅÔ∏è ESP: OFF"
espBtn.Font = Enum.Font.GothamBold
espBtn.TextSize = 12
espBtn.TextColor3 = Color3.new(1, 1, 1)
espBtn.Parent = mainFrame

local espCorner = Instance.new("UICorner")
espCorner.CornerRadius = UDim.new(0, 8)
espCorner.Parent = espBtn

-- Triggerbot Toggle Button - NEW
local triggerbotBtn = Instance.new("TextButton")
triggerbotBtn.Size = UDim2.new(1, -20, 0, 32)
triggerbotBtn.Position = UDim2.new(0, 10, 0, 168)
triggerbotBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 100)
triggerbotBtn.Text = "üéØ Triggerbot: OFF"
triggerbotBtn.Font = Enum.Font.GothamBold
triggerbotBtn.TextSize = 12
triggerbotBtn.TextColor3 = Color3.new(1, 1, 1)
triggerbotBtn.Parent = mainFrame

local triggerbotCorner = Instance.new("UICorner")
triggerbotCorner.CornerRadius = UDim.new(0, 8)
triggerbotCorner.Parent = triggerbotBtn

-- Smoothness Label
local smoothLabel = Instance.new("TextLabel")
smoothLabel.Size = UDim2.new(1, -20, 0, 20)
smoothLabel.Position = UDim2.new(0, 10, 0, 210)
smoothLabel.BackgroundTransparency = 1
smoothLabel.Text = "Smoothness: 0.25"
smoothLabel.Font = Enum.Font.Gotham
smoothLabel.TextSize = 12
smoothLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
smoothLabel.TextXAlignment = Enum.TextXAlignment.Left
smoothLabel.Parent = mainFrame

-- Smoothness Slider
local sliderFrame = Instance.new("Frame")
sliderFrame.Size = UDim2.new(1, -20, 0, 8)
sliderFrame.Position = UDim2.new(0, 10, 0, 235)
sliderFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
sliderFrame.BorderSizePixel = 0
sliderFrame.Parent = mainFrame

local sliderCorner = Instance.new("UICorner")
sliderCorner.CornerRadius = UDim.new(0.5, 0)
sliderCorner.Parent = sliderFrame

local sliderFill = Instance.new("Frame")
sliderFill.Size = UDim2.new(0.25, 0, 1, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
sliderFill.BorderSizePixel = 0
sliderFill.Parent = sliderFrame

local fillCorner = Instance.new("UICorner")
fillCorner.CornerRadius = UDim.new(0.5, 0)
fillCorner.Parent = sliderFill

local sliderKnob = Instance.new("TextButton")
sliderKnob.Size = UDim2.new(0, 16, 0, 16)
sliderKnob.Position = UDim2.new(0.25, -8, 0.5, -8)
sliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
sliderKnob.Text = ""
sliderKnob.Parent = sliderFrame

local knobCorner = Instance.new("UICorner")
knobCorner.CornerRadius = UDim.new(0.5, 0)
knobCorner.Parent = sliderKnob

-- Wall Detection Toggle
local wallCheckBtn = Instance.new("TextButton")
wallCheckBtn.Size = UDim2.new(0.48, 0, 0, 30)
wallCheckBtn.Position = UDim2.new(0, 10, 0, 255)
wallCheckBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
wallCheckBtn.Text = "Wall: ON"
wallCheckBtn.Font = Enum.Font.GothamBold
wallCheckBtn.TextSize = 11
wallCheckBtn.TextColor3 = Color3.new(1, 1, 1)
wallCheckBtn.Parent = mainFrame

local wallCorner = Instance.new("UICorner")
wallCorner.CornerRadius = UDim.new(0, 6)
wallCorner.Parent = wallCheckBtn

-- Team Check Toggle
local teamCheckBtn = Instance.new("TextButton")
teamCheckBtn.Size = UDim2.new(0.48, 0, 0, 30)
teamCheckBtn.Position = UDim2.new(0.52, 0, 0, 255)
teamCheckBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
teamCheckBtn.Text = "Team: ON"
teamCheckBtn.Font = Enum.Font.GothamBold
teamCheckBtn.TextSize = 11
teamCheckBtn.TextColor3 = Color3.new(1, 1, 1)
teamCheckBtn.Parent = mainFrame

local teamCorner = Instance.new("UICorner")
teamCorner.CornerRadius = UDim.new(0, 6)
teamCorner.Parent = teamCheckBtn

-- Distance Label
local distLabel = Instance.new("TextLabel")
distLabel.Size = UDim2.new(1, -20, 0, 20)
distLabel.Position = UDim2.new(0, 10, 0, 295)
distLabel.BackgroundTransparency = 1
distLabel.Text = "Max Distance: 300"
distLabel.Font = Enum.Font.Gotham
distLabel.TextSize = 12
distLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
distLabel.TextXAlignment = Enum.TextXAlignment.Left
distLabel.Parent = mainFrame

-- Distance Slider
local distSliderFrame = Instance.new("Frame")
distSliderFrame.Size = UDim2.new(1, -20, 0, 8)
distSliderFrame.Position = UDim2.new(0, 10, 0, 320)
distSliderFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
distSliderFrame.BorderSizePixel = 0
distSliderFrame.Parent = mainFrame

local distSliderCorner = Instance.new("UICorner")
distSliderCorner.CornerRadius = UDim.new(0.5, 0)
distSliderCorner.Parent = distSliderFrame

local distSliderFill = Instance.new("Frame")
distSliderFill.Size = UDim2.new(0.15, 0, 1, 0)
distSliderFill.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
distSliderFill.BorderSizePixel = 0
distSliderFill.Parent = distSliderFrame

local distFillCorner = Instance.new("UICorner")
distFillCorner.CornerRadius = UDim.new(0.5, 0)
distFillCorner.Parent = distSliderFill

local distSliderKnob = Instance.new("TextButton")
distSliderKnob.Size = UDim2.new(0, 16, 0, 16)
distSliderKnob.Position = UDim2.new(0.15, -8, 0.5, -8)
distSliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
distSliderKnob.Text = ""
distSliderKnob.Parent = distSliderFrame

local distKnobCorner = Instance.new("UICorner")
distKnobCorner.CornerRadius = UDim.new(0.5, 0)
distKnobCorner.Parent = distSliderKnob

-- Info Label
local infoLabel = Instance.new("TextLabel")
infoLabel.Size = UDim2.new(1, -20, 0, 40)
infoLabel.Position = UDim2.new(0, 10, 0, 335)
infoLabel.BackgroundTransparency = 1
infoLabel.Text = "üéØ Body Part: HEAD\nDrag to reposition"
infoLabel.Font = Enum.Font.Gotham
infoLabel.TextSize = 9
infoLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
infoLabel.TextXAlignment = Enum.TextXAlignment.Center
infoLabel.Parent = mainFrame

-- Settings
local smoothness = 0.25
local wallCheckEnabled = true
local teamCheckEnabled = true
local maxDistance = 300
local triggerbotDelay = 50
local triggerbotHold = 100

-- ESP Storage
local espHighlights = {}

-- Velocity prediction storage (IMPROVED)
local targetVelocities = {}
local lastUpdateTime = tick()

-- Dragging for main frame
local dragging = false
local dragStart, startPos

dragHandle.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = mainFrame.Position
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

dragHandle.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			local delta = input.Position - dragStart
			mainFrame.Position = UDim2.new(
				startPos.X.Scale, startPos.X.Offset + delta.X,
				startPos.Y.Scale, startPos.Y.Offset + delta.Y
			)
		end
	end
end)

-- Dragging for mini button
local miniDragging = false
local miniDragStart, miniStartPos

miniBtn.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		miniDragging = true
		miniDragStart = input.Position
		miniStartPos = miniBtn.Position
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				miniDragging = false
			end
		end)
	end
end)

miniBtn.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if miniDragging then
			local delta = input.Position - miniDragStart
			miniBtn.Position = UDim2.new(
				miniStartPos.X.Scale, miniStartPos.X.Offset + delta.X,
				miniStartPos.Y.Scale, miniStartPos.Y.Offset + delta.Y
			)
		end
	end
end)

-- Minimize/Maximize
local isMinimized = false

minimizeBtn.Activated:Connect(function()
	isMinimized = true
	
	TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
		Size = UDim2.new(0, 0, 0, 0)
	}):Play()
	
	task.wait(0.3)
	mainFrame.Visible = false
	miniBtn.Visible = true
	
	miniBtn.Size = UDim2.new(0, 0, 0, 0)
	TweenService:Create(miniBtn, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Size = UDim2.new(0, 50, 0, 50)
	}):Play()
end)

miniBtn.Activated:Connect(function()
	if not miniDragging then
		isMinimized = false
		
		TweenService:Create(miniBtn, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 0, 0, 0)
		}):Play()
		
		task.wait(0.2)
		miniBtn.Visible = false
		mainFrame.Visible = true
		
		mainFrame.Size = UDim2.new(0, 0, 0, 0)
		TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, 160, 0, 370)
		}):Play()
	end
end)

-- Triggerbot Delay Slider
local delaySliderDragging = false

delaySliderKnob.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		delaySliderDragging = true
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				delaySliderDragging = false
			end
		end)
	end
end)

delaySliderKnob.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if delaySliderDragging then
			local mousePos = input.Position
			local sliderPos = delaySliderFrame.AbsolutePosition
			local sliderSize = delaySliderFrame.AbsoluteSize
			
			local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
			triggerbotDelay = math.floor(relativeX * 500)
			
			delaySliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
			delaySliderKnob.Position = UDim2.new(relativeX, -7, 0.5, -7)
			delayLabel.Text = "Delay: " .. triggerbotDelay .. "ms"
		end
	end
end)

-- Triggerbot Hold Slider
local holdSliderDragging = false

holdSliderKnob.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		holdSliderDragging = true
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				holdSliderDragging = false
			end
		end)
	end
end)

holdSliderKnob.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if holdSliderDragging then
			local mousePos = input.Position
			local sliderPos = holdSliderFrame.AbsolutePosition
			local sliderSize = holdSliderFrame.AbsoluteSize
			
			local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
			triggerbotHold = math.floor(relativeX * 500)
			
			holdSliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
			holdSliderKnob.Position = UDim2.new(relativeX, -7, 0.5, -7)
			holdLabel.Text = "Hold: " .. triggerbotHold .. "ms"
		end
	end
end)

-- Smoothness slider
local sliderDragging = false

sliderKnob.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		sliderDragging = true
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				sliderDragging = false
			end
		end)
	end
end)

sliderKnob.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if sliderDragging then
			local mousePos = input.Position
			local sliderPos = sliderFrame.AbsolutePosition
			local sliderSize = sliderFrame.AbsoluteSize
			
			local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
			smoothness = math.clamp(relativeX, 0.05, 0.95)
			
			sliderFill.Size = UDim2.new(smoothness, 0, 1, 0)
			sliderKnob.Position = UDim2.new(smoothness, -8, 0.5, -8)
			smoothLabel.Text = "Smoothness: " .. string.format("%.2f", smoothness)
		end
	end
end)

-- Distance slider
local distSliderDragging = false

distSliderKnob.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		distSliderDragging = true
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				distSliderDragging = false
			end
		end)
	end
end)

distSliderKnob.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if distSliderDragging then
			local mousePos = input.Position
			local sliderPos = distSliderFrame.AbsolutePosition
			local sliderSize = distSliderFrame.AbsoluteSize
			
			local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
			maxDistance = math.floor(relativeX * 2000)
			
			if maxDistance < 50 then maxDistance = 50 end
			
			distSliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
			distSliderKnob.Position = UDim2.new(relativeX, -8, 0.5, -8)
			distLabel.Text = "Max Distance: " .. maxDistance
		end
	end
end)

-- Wall detection toggle
wallCheckBtn.Activated:Connect(function()
	wallCheckEnabled = not wallCheckEnabled
	
	if wallCheckEnabled then
		wallCheckBtn.Text = "Wall: ON"
		wallCheckBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
	else
		wallCheckBtn.Text = "Wall: OFF"
		wallCheckBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
	end
end)

-- Team check toggle
teamCheckBtn.Activated:Connect(function()
	teamCheckEnabled = not teamCheckEnabled
	
	if teamCheckEnabled then
		teamCheckBtn.Text = "Team: ON"
		teamCheckBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
	else
		teamCheckBtn.Text = "Team: OFF"
		teamCheckBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
	end
end)

-- Advanced Aim toggle
advancedBtn.Activated:Connect(function()
	advancedAimEnabled = not advancedAimEnabled
	
	if advancedAimEnabled then
		advancedBtn.Text = "üéØ Adv Aim: ON"
		advancedBtn.BackgroundColor3 = Color3.fromRGB(255, 150, 80)
	else
		advancedBtn.Text = "üéØ Adv Aim: OFF"
		advancedBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
		targetVelocities = {}
	end
end)

-- Main Toggle
toggleBtn.Activated:Connect(function()
	aimAssistEnabled = not aimAssistEnabled
	
	if aimAssistEnabled then
		toggleBtn.Text = "ENABLED"
		toggleBtn.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
		statusDot.BackgroundColor3 = Color3.fromRGB(80, 255, 100)
	else
		toggleBtn.Text = "DISABLED"
		toggleBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
		statusDot.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
		currentTarget = nil
		targetVelocities = {}
	end
end)

-- Check if on same team
local function isTeammate(targetPlayer)
	if not teamCheckEnabled then return false end
	if not Teams or not player.Team then return false end
	if not targetPlayer or not targetPlayer.Team then return false end
	return player.Team == targetPlayer.Team
end

-- Wall detection using Raycast (IMPROVED - 5-Point System)
local function hasLineOfSight(targetPart)
	if not wallCheckEnabled then return true end
	if not hrp or not targetPart then return false end
	
	local origin = camera.CFrame.Position
	local targetPos = targetPart.Position
	local direction = (targetPos - origin).Unit
	local distance = (targetPos - origin).Magnitude
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, targetPart.Parent}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.IgnoreWater = true
	
	-- Primary raycast (center)
	local result = workspace:Raycast(origin, direction * distance, raycastParams)
	
	if not result then
		return true
	end
	
	-- Multi-point detection for small openings
	local offsets = {
		Vector3.new(0.5, 0, 0),
		Vector3.new(-0.5, 0, 0),
		Vector3.new(0, 0.5, 0),
		Vector3.new(0, -0.5, 0)
	}
	
	for _, offset in ipairs(offsets) do
		local offsetTarget = targetPos + offset
		local offsetDirection = (offsetTarget - origin).Unit
		local offsetDistance = (offsetTarget - origin).Magnitude
		
		local offsetResult = workspace:Raycast(origin, offsetDirection * offsetDistance, raycastParams)
		
		if not offsetResult then
			return true
		end
	end
	
	return false
end

-- Get target part from character
local function getTargetPart(targetChar)
	local part = targetChar:FindFirstChild(aimPart)
	
	if not part then
		if aimPart == "Neck" then
			part = targetChar:FindFirstChild("UpperTorso") or targetChar:FindFirstChild("Torso")
		elseif aimPart == "Left Leg" then
			part = targetChar:FindFirstChild("LeftUpperLeg") or targetChar:FindFirstChild("Left Leg")
		end
	end
	
	return part or targetChar:FindFirstChild("Head")
end

-- Calculate velocity prediction (IMPROVED)
local function getPredictedPosition(targetPart)
	if not advancedAimEnabled then
		return targetPart.Position
	end
	
	local targetChar = targetPart.Parent
	if not targetChar then return targetPart.Position end
	
	local targetId = targetChar.Name
	local currentPos = targetPart.Position
	local currentTime = tick()
	
	local actualVelocity = targetPart.AssemblyLinearVelocity or targetPart.Velocity or Vector3.zero
	
	if not targetVelocities[targetId] then
		targetVelocities[targetId] = {
			lastPos = currentPos,
			lastTime = currentTime,
			velocity = actualVelocity,
			smoothVelocity = actualVelocity,
			isMoving = false
		}
		return currentPos
	end
	
	local data = targetVelocities[targetId]
	local deltaTime = currentTime - data.lastTime
	
	if deltaTime > 0.05 then
		local deltaPos = currentPos - data.lastPos
		local calculatedVelocity = deltaPos / deltaTime
		
		local velocity = actualVelocity
		if velocity.Magnitude < 0.5 then
			velocity = calculatedVelocity
		end
		
		local speed = velocity.Magnitude
		data.isMoving = speed > 1
		
		if data.isMoving then
			data.smoothVelocity = data.smoothVelocity:Lerp(velocity, 0.7)
		else
			data.smoothVelocity = data.smoothVelocity:Lerp(Vector3.zero, 0.9)
		end
		
		data.velocity = velocity
		data.lastPos = currentPos
		data.lastTime = currentTime
	end
	
	if data.isMoving and data.smoothVelocity.Magnitude > 0.5 then
		local distance = (currentPos - camera.CFrame.Position).Magnitude
		local predictionTime = math.clamp(distance / 500, 0.1, 0.25)
		
		local gravityOffset = Vector3.zero
		if data.smoothVelocity.Y < -5 then
			gravityOffset = Vector3.new(0, -9.8 * predictionTime * predictionTime * 0.5, 0)
		end
		
		return currentPos + (data.smoothVelocity * predictionTime) + gravityOffset
	else
		return currentPos
	end
end

-- Get valid target
local function getClosestTarget()
	if not camera or not hrp then return nil end
	
	local closestTarget = nil
	local closestDistance = math.huge
	local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
	
	for _, targetPlayer in ipairs(Players:GetPlayers()) do
		if targetPlayer ~= player and targetPlayer.Character then
			if isTeammate(targetPlayer) then continue end
			
			local targetChar = targetPlayer.Character
			local targetPart = getTargetPart(targetChar)
			local targetHum = targetChar:FindFirstChildWhichIsA("Humanoid")
			
			if targetPart and targetHum and targetHum.Health > 0 then
				local distance = (targetPart.Position - hrp.Position).Magnitude
				
				if distance > maxDistance then continue end
				
				if not hasLineOfSight(targetPart) then continue end
				
				local screenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
				if onScreen then
					local screenDistance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
					
					if screenDistance < FOV_RADIUS and screenDistance < closestDistance then
						closestDistance = screenDistance
						closestTarget = targetPart
					end
				end
			end
		end
	end
	
	return closestTarget
end

-- ESP Functions (HEAVY MONITORING)
local function createESP(targetPlayer)
	if targetPlayer == player then return end
	if espHighlights[targetPlayer] and espHighlights[targetPlayer].Parent then return end
	
	local char = targetPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") then return end
	
	if espHighlights[targetPlayer] then
		pcall(function() espHighlights[targetPlayer]:Destroy() end)
	end
	
	local highlight = Instance.new("Highlight")
	highlight.FillColor = Color3.fromRGB(255, 80, 80)
	highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Parent = char
	
	espHighlights[targetPlayer] = highlight
	
	spawn(function()
		while espEnabled and targetPlayer and targetPlayer.Parent do
			wait(1)
			if not highlight or not highlight.Parent or highlight.Parent ~= char then
				if espEnabled then
					createESP(targetPlayer)
				end
				break
			end
		end
	end)
end

local function removeESP(targetPlayer)
	if espHighlights[targetPlayer] then
		pcall(function() espHighlights[targetPlayer]:Destroy() end)
		espHighlights[targetPlayer] = nil
	end
end

local function clearAllESP()
	for targetPlayer, _ in pairs(espHighlights) do
		removeESP(targetPlayer)
	end
end

-- ESP 6 Monitoring Systems
spawn(function()
	while true do
		wait(0.5)
		
		if espEnabled then
			for _, targetPlayer in ipairs(Players:GetPlayers()) do
				if targetPlayer ~= player and targetPlayer.Character then
					if not espHighlights[targetPlayer] or not espHighlights[targetPlayer].Parent then
						createESP(targetPlayer)
					end
				end
			end
		end
	end
end)

for _, targetPlayer in ipairs(Players:GetPlayers()) do
	if targetPlayer ~= player then
		targetPlayer.CharacterAdded:Connect(function(char)
			if espEnabled then
				wait(0.3)
				createESP(targetPlayer)
			end
		end)
		
		targetPlayer.CharacterRemoving:Connect(function()
			removeESP(targetPlayer)
		end)
	end
end

Players.PlayerAdded:Connect(function(targetPlayer)
	if targetPlayer ~= player then
		targetPlayer.CharacterAdded:Connect(function(char)
			if espEnabled then
				wait(0.3)
				createESP(targetPlayer)
			end
		end)
		
		targetPlayer.CharacterRemoving:Connect(function()
			removeESP(targetPlayer)
		end)
	end
end)

Players.PlayerRemoving:Connect(function(targetPlayer)
	removeESP(targetPlayer)
end)

spawn(function()
	while true do
		wait(1)
		
		if espEnabled then
			for _, obj in ipairs(workspace:GetChildren()) do
				if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("HumanoidRootPart") then
					local targetPlayer = Players:GetPlayerFromCharacter(obj)
					if targetPlayer and targetPlayer ~= player then
						if not espHighlights[targetPlayer] or not espHighlights[targetPlayer].Parent then
							createESP(targetPlayer)
						end
					end
				end
			end
		end
	end
end)

RunService.RenderStepped:Connect(function()
	if espEnabled then
		local currentTime = tick()
		if currentTime - lastUpdateTime > 0.1 then
			lastUpdateTime = currentTime
			
			for _, targetPlayer in ipairs(Players:GetPlayers()) do
				if targetPlayer ~= player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
					if not espHighlights[targetPlayer] or not espHighlights[targetPlayer].Parent then
						createESP(targetPlayer)
					end
				end
			end
		end
	end
end)

-- ESP Toggle
espBtn.Activated:Connect(function()
	espEnabled = not espEnabled
	
	if espEnabled then
		espBtn.Text = "üëÅÔ∏è ESP: ON"
		espBtn.BackgroundColor3 = Color3.fromRGB(150, 80, 255)
		
		task.spawn(function()
			for _, targetPlayer in ipairs(Players:GetPlayers()) do
				if targetPlayer ~= player then
					if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
						createESP(targetPlayer)
					end
				end
			end
		end)
	else
		espBtn.Text = "üëÅÔ∏è ESP: OFF"
		espBtn.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
		clearAllESP()
	end
end)

-- MOBILE TRIGGERBOT SYSTEM (Proper Implementation - No Movement Block!)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualUser = game:GetService("VirtualUser")

local function fireWeapon()
	-- METHOD 1: Tool Activation (Best for Mobile - No Touch Blocking!)
	pcall(function()
		local tool = character and character:FindFirstChildOfClass("Tool")
		if tool then
			tool:Activate()
			task.wait(triggerbotHold / 1000)
			tool:Deactivate()
			return
		end
	end)
	
	-- METHOD 2: RemoteEvent Detection (Game-Specific Shooting)
	pcall(function()
		-- Look for common shooting remotes in ReplicatedStorage
		local remotes = ReplicatedStorage:GetDescendants()
		for _, remote in ipairs(remotes) do
			if remote:IsA("RemoteEvent") and (
				remote.Name:lower():find("shoot") or 
				remote.Name:lower():find("fire") or
				remote.Name:lower():find("attack") or
				remote.Name:lower():find("damage")
			) then
				remote:FireServer()
				task.wait(triggerbotHold / 1000)
				return
			end
		end
	end)
	
	-- METHOD 3: Context Action Button Press (Mobile Fire Button)
	pcall(function()
		local ContextActionService = game:GetService("ContextActionService")
		local actions = ContextActionService:GetAllBoundActionInfo()
		
		for actionName, actionInfo in pairs(actions) do
			if actionName:lower():find("fire") or actionName:lower():find("shoot") or actionName:lower():find("action") then
				ContextActionService:BindAction(actionName, function() end, false)
				ContextActionService:CallFunction(actionName, "Begin")
				task.wait(triggerbotHold / 1000)
				ContextActionService:CallFunction(actionName, "End")
				return
			end
		end
	end)
	
	-- METHOD 4: GuiButton Detection (Mobile Shoot Button)
	pcall(function()
		local playerGui = player:WaitForChild("PlayerGui")
		for _, gui in ipairs(playerGui:GetDescendants()) do
			if gui:IsA("GuiButton") or gui:IsA("ImageButton") then
				local name = gui.Name:lower()
				if name:find("fire") or name:find("shoot") or name:find("attack") then
					-- Simulate button press without blocking touch
					for _, connection in ipairs(getconnections(gui.MouseButton1Click)) do
						connection:Fire()
					end
					task.wait(triggerbotHold / 1000)
					return
				end
			end
		end
	end)
	
	-- METHOD 5: VirtualUser Button1Down (Last Resort - Safer than VirtualInputManager)
	pcall(function()
		if UserInputService.TouchEnabled then
			-- Use screen center position instead of 0,0 to avoid blocking movement
			local screenCenter = camera.ViewportSize / 2
			VirtualUser:Button1Down(Vector2.new(screenCenter.X, screenCenter.Y))
			task.wait(triggerbotHold / 1000)
			VirtualUser:Button1Up(Vector2.new(screenCenter.X, screenCenter.Y))
		end
	end)
	
	-- METHOD 6: Mouse1 for PC (Fallback)
	pcall(function()
		if mouse1press and mouse1release and not UserInputService.TouchEnabled then
			mouse1press()
			task.wait(triggerbotHold / 1000)
			mouse1release()
		end
	end)
end

local function getMouseTarget()
	if not hrp then return nil end
	
	-- METHOD 1: Mouse.Target (Most Common)
	local mouse = player:GetMouse()
	if mouse and mouse.Target then
		local target = mouse.Target
		local targetModel = target:FindFirstAncestorOfClass("Model")
		
		if targetModel then
			local targetPlayer = Players:GetPlayerFromCharacter(targetModel)
			if targetPlayer and targetPlayer ~= player then
				if teamCheckEnabled and isTeammate(targetPlayer) then return nil end
				
				local targetHum = targetModel:FindFirstChildWhichIsA("Humanoid")
				if targetHum and targetHum.Health > 0 then
					local targetHRP = targetModel:FindFirstChild("HumanoidRootPart")
					if targetHRP then
						local distance = (targetHRP.Position - hrp.Position).Magnitude
						if distance <= maxDistance then
							return targetModel
						end
					end
				end
			end
		end
	end
	
	-- METHOD 2: Camera Raycast (More Reliable)
	local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
	local unitRay = camera:ViewportPointToRay(screenCenter.X, screenCenter.Y)
	
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.IgnoreWater = true
	
	local rayResult = workspace:Raycast(unitRay.Origin, unitRay.Direction * maxDistance, raycastParams)
	
	if rayResult and rayResult.Instance then
		local targetModel = rayResult.Instance:FindFirstAncestorOfClass("Model")
		
		if targetModel then
			local targetPlayer = Players:GetPlayerFromCharacter(targetModel)
			if targetPlayer and targetPlayer ~= player then
				if teamCheckEnabled and isTeammate(targetPlayer) then return nil end
				
				local targetHum = targetModel:FindFirstChildWhichIsA("Humanoid")
				if targetHum and targetHum.Health > 0 then
					return targetModel
				end
			end
		end
	end
	
	-- METHOD 3: Screen Center FOV Check (Backup)
	for _, targetPlayer in ipairs(Players:GetPlayers()) do
		if targetPlayer ~= player and targetPlayer.Character then
			if teamCheckEnabled and isTeammate(targetPlayer) then continue end
			
			local targetChar = targetPlayer.Character
			local targetHum = targetChar:FindFirstChildWhichIsA("Humanoid")
			local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
			
			if targetHum and targetHum.Health > 0 and targetHRP then
				local distance = (targetHRP.Position - hrp.Position).Magnitude
				if distance <= maxDistance then
					local screenPos, onScreen = camera:WorldToViewportPoint(targetHRP.Position)
					if onScreen then
						local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
						if distanceFromCenter < 50 then
							return targetChar
						end
					end
				end
			end
		end
	end
	
	return nil
end

local triggerbotCooldown = false
local lastTarget = nil
local lastFireTime = 0

-- Triggerbot Loop (Mobile Safe - Won't Block Movement!)
RunService.Heartbeat:Connect(function()
	if not triggerbotEnabled or triggerbotCooldown then return end
	
	-- Throttle to avoid spam
	local currentTime = tick()
	if currentTime - lastFireTime < 0.1 then return end
	
	local target = getMouseTarget()
	
	if target then
		triggerbotCooldown = true
		lastTarget = target
		
		-- Delay before shooting
		task.wait(triggerbotDelay / 1000)
		
		-- Verify target is still valid
		local currentTarget = getMouseTarget()
		if currentTarget == target then
			-- Fire! (Mobile Safe - Multiple Methods)
			lastFireTime = tick()
			fireWeapon()
		end
		
		-- Cooldown
		task.wait(0.05)
		triggerbotCooldown = false
	end
end)

-- Triggerbot Toggle
triggerbotBtn.Activated:Connect(function()
	triggerbotEnabled = not triggerbotEnabled
	
	if triggerbotEnabled then
		triggerbotBtn.Text = "üéØ Triggerbot: ON"
		triggerbotBtn.BackgroundColor3 = Color3.fromRGB(255, 80, 120)
	else
		triggerbotBtn.Text = "üéØ Triggerbot: OFF"
		triggerbotBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 100)
	end
end)

-- Update info label
spawn(function()
	while true do
		wait(0.5)
		if bodyPartButtons[currentBodyPart] then
			local partName = bodyPartButtons[currentBodyPart].part.name
			infoLabel.Text = "üéØ Body Part: " .. partName .. "\nDrag to reposition"
		end
	end
end)

-- Aim assist loop
RunService.RenderStepped:Connect(function()
	if not aimAssistEnabled or not camera then return end
	
	currentTarget = getClosestTarget()
	
	if currentTarget then
		local targetPos = getPredictedPosition(currentTarget)
		local currentCFrame = camera.CFrame
		local desiredCFrame = CFrame.new(currentCFrame.Position, targetPos)
		camera.CFrame = currentCFrame:Lerp(desiredCFrame, smoothness)
	end
end)

print("========================================")
print("Enhanced Aim Assist [MOBILE OPTIMIZED]")
print("========================================")
print("‚úÖ Body Part Selection (Head/Neck/Torso/Leg)")
print("‚úÖ Advanced Aim (IMPROVED Accuracy)")
print("‚úÖ ESP (6 MONITORING SYSTEMS)")
print("‚úÖ Wall Detection (5-Point Raycast)")
print("‚úÖ Triggerbot (6 Methods - NO MOVEMENT BLOCK!)")
print("üí° 2 [+] buttons for settings")
print("üì± MOBILE SAFE - Won't interfere with controls!")
print("üéØ Methods: Tool/Remote/Context/Button/VirtualUser/Mouse")
print("========================================")
