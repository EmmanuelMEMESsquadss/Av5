-- LocalScript (StarterPlayerScripts)
-- Mobile Lock-On System [SMART CFRAME - CONFLICT RESISTANT]
-- Detects conflicts EARLY + Smooth transitions + Physics-aware

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

if not UserInputService.TouchEnabled then return end

local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local character, humanoid, hrp
local isDisabled = false
local isTransitioning = false -- NEW: Smooth transition flag

-- NEW: Conflict detection
local lastCFrameSet = nil
local conflictCounter = 0
local CONFLICT_THRESHOLD = 3 -- If CFrame changes unexpectedly 3 times, we have conflict

local function setupCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
	
	-- Reset conflict detection
	lastCFrameSet = nil
	conflictCounter = 0
	
	if humanoid then 
		humanoid.AutoRotate = true 
		
		-- IMPROVED: Predictive state detection
		humanoid.StateChanged:Connect(function(oldState, newState)
			-- Start transition BEFORE fully ragdolled
			if newState == Enum.HumanoidStateType.Physics or 
				newState == Enum.HumanoidStateType.Ragdoll or
				newState == Enum.HumanoidStateType.FallingDown or
				newState == Enum.HumanoidStateType.PlatformStanding then
				
				isTransitioning = true -- Start smooth release
				task.wait(0.1) -- Brief transition period
				isDisabled = true
				
			elseif newState == Enum.HumanoidStateType.Running or
				newState == Enum.HumanoidStateType.Landed or
				newState == Enum.HumanoidStateType.Jumping then
				
				isDisabled = false
				task.wait(0.05) -- Brief delay before re-engaging
				isTransitioning = false
			end
		end)
		
		humanoid:GetPropertyChangedSignal("PlatformStand"):Connect(function()
			if humanoid.PlatformStand then
				isTransitioning = true
				task.wait(0.1)
				isDisabled = true
			else
				isDisabled = false
				task.wait(0.05)
				isTransitioning = false
			end
		end)
		
		humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
			if humanoid.Sit then
				isTransitioning = true
				task.wait(0.1)
				isDisabled = true
			end
		end)
	end
	
	if hrp then
		-- IMPROVED: Detect constraints being added (grab detection)
		hrp.ChildAdded:Connect(function(child)
			if child:IsA("Weld") or child:IsA("WeldConstraint") or 
				child:IsA("AlignPosition") or child:IsA("AlignOrientation") or
				child:IsA("RopeConstraint") then
				
				-- Don't include OUR own constraint
				if child.Name == "CharLockOrientation" then return end
				
				isTransitioning = true
				task.wait(0.1)
				isDisabled = true
				
				child.AncestryChanged:Connect(function()
					if not child:IsDescendantOf(game) then
						task.wait(0.5)
						isDisabled = false
						task.wait(0.05)
						isTransitioning = false
					end
				end)
			end
		end)
		
		-- NEW: Monitor velocity spikes (knockback/ragdoll detection)
		spawn(function()
			local lastVelocity = hrp.AssemblyLinearVelocity
			while hrp and hrp.Parent do
				wait(0.05)
				local currentVelocity = hrp.AssemblyLinearVelocity
				local velocityChange = (currentVelocity - lastVelocity).Magnitude
				
				-- If velocity suddenly changes by >50 studs/sec, likely knockback/ragdoll
				if velocityChange > 50 and not isDisabled then
					isTransitioning = true
					task.wait(0.1)
					isDisabled = true
				end
				
				lastVelocity = currentVelocity
			end
		end)
	end
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- GUI Setup (same as before)
local gui = Instance.new("ScreenGui")
gui.Name = "LockOnUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local charLockBtn = Instance.new("TextButton")
charLockBtn.Size = UDim2.new(0, 110, 0, 50)
charLockBtn.Position = UDim2.new(0.06, 0, 0.8, 0)
charLockBtn.Text = "CHAR LOCK"
charLockBtn.BackgroundColor3 = Color3.fromRGB(36, 137, 206)
charLockBtn.TextColor3 = Color3.new(1, 1, 1)
charLockBtn.Font = Enum.Font.GothamBold
charLockBtn.TextSize = 16
charLockBtn.Active = true
charLockBtn.Parent = gui

local charCorner = Instance.new("UICorner")
charCorner.CornerRadius = UDim.new(0, 8)
charCorner.Parent = charLockBtn

local charDot = Instance.new("Frame")
charDot.Size = UDim2.new(0, 8, 0, 8)
charDot.Position = UDim2.new(1, -12, 0, 4)
charDot.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
charDot.BorderSizePixel = 0
charDot.Parent = charLockBtn

local charDotCorner = Instance.new("UICorner")
charDotCorner.CornerRadius = UDim.new(0.5, 0)
charDotCorner.Parent = charDot

local profileBtn = Instance.new("TextButton")
profileBtn.Size = UDim2.new(0, 24, 0, 24)
profileBtn.Position = UDim2.new(0, -30, 0, 13)
profileBtn.Text = "+"
profileBtn.BackgroundColor3 = Color3.fromRGB(46, 147, 216)
profileBtn.TextColor3 = Color3.new(1, 1, 1)
profileBtn.Font = Enum.Font.GothamBold
profileBtn.TextSize = 20
profileBtn.Active = true
profileBtn.ZIndex = 10
profileBtn.Parent = charLockBtn

local profileCorner = Instance.new("UICorner")
profileCorner.CornerRadius = UDim.new(0.5, 0)
profileCorner.Parent = profileBtn

local profileMenu = Instance.new("Frame")
profileMenu.Size = UDim2.new(0, 160, 0, 0)
profileMenu.Position = UDim2.new(0, -30, 0, 40)
profileMenu.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
profileMenu.BorderSizePixel = 0
profileMenu.ClipsDescendants = true
profileMenu.Visible = false
profileMenu.ZIndex = 5
profileMenu.Parent = charLockBtn

local menuCorner = Instance.new("UICorner")
menuCorner.CornerRadius = UDim.new(0, 8)
menuCorner.Parent = profileMenu

-- Smart profiles with conflict handling
local profiles = {
	{name = "SMOOTH", desc = "Natural", smoothness = 0.12, conflictMode = "blend", color = Color3.fromRGB(80, 200, 120)},
	{name = "SNAP", desc = "Instant", smoothness = 0.35, conflictMode = "force", color = Color3.fromRGB(255, 140, 60)},
	{name = "BUTTER", desc = "Ultra Smooth", smoothness = 0.06, conflictMode = "blend", color = Color3.fromRGB(100, 180, 255)},
	{name = "ADAPT", desc = "Smart", smoothness = 0.15, conflictMode = "auto", color = Color3.fromRGB(200, 100, 255)}
}

local currentProfile = 1
local profileButtons = {}

for i, profile in ipairs(profiles) do
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(1, -10, 0, 35)
	btn.Position = UDim2.new(0, 5, 0, 5 + (i-1) * 40)
	btn.BackgroundColor3 = profile.color
	btn.BackgroundTransparency = 0.2
	btn.BorderSizePixel = 0
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 13
	btn.TextColor3 = Color3.new(1, 1, 1)
	btn.Text = profile.name .. " Â· " .. profile.desc
	btn.ZIndex = 6
	btn.Parent = profileMenu
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 6)
	btnCorner.Parent = btn
	
	local indicator = Instance.new("Frame")
	indicator.Size = UDim2.new(0, 4, 1, -6)
	indicator.Position = UDim2.new(0, 3, 0, 3)
	indicator.BackgroundColor3 = Color3.new(1, 1, 1)
	indicator.BorderSizePixel = 0
	indicator.Visible = (i == 1)
	indicator.ZIndex = 7
	indicator.Parent = btn
	
	local indCorner = Instance.new("UICorner")
	indCorner.CornerRadius = UDim.new(1, 0)
	indCorner.Parent = indicator
	
	profileButtons[i] = {button = btn, indicator = indicator, profile = profile}
	
	btn.Activated:Connect(function()
		currentProfile = i
		SMOOTHNESS = profile.smoothness
		CONFLICT_MODE = profile.conflictMode
		
		for j, data in ipairs(profileButtons) do
			data.indicator.Visible = (j == i)
			TweenService:Create(data.button, TweenInfo.new(0.2), {
				BackgroundTransparency = (j == i) and 0.2 or 0.5
			}):Play()
		end
		
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(1, -8, 0, 35)
		}):Play()
		task.wait(0.1)
		TweenService:Create(btn, TweenInfo.new(0.1), {
			Size = UDim2.new(1, -10, 0, 35)
		}):Play()
	end)
end

local menuOpen = false
profileBtn.Activated:Connect(function()
	menuOpen = not menuOpen
	
	if menuOpen then
		profileMenu.Visible = true
		TweenService:Create(profileMenu, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Size = UDim2.new(0, 160, 0, 165)
		}):Play()
		TweenService:Create(profileBtn, TweenInfo.new(0.2), {
			Rotation = 45,
			BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		}):Play()
	else
		TweenService:Create(profileMenu, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
			Size = UDim2.new(0, 160, 0, 0)
		}):Play()
		TweenService:Create(profileBtn, TweenInfo.new(0.2), {
			Rotation = 0,
			BackgroundColor3 = Color3.fromRGB(46, 147, 216)
		}):Play()
		task.wait(0.2)
		profileMenu.Visible = false
	end
end)

local camLockBtn = Instance.new("TextButton")
camLockBtn.Size = UDim2.new(0, 110, 0, 50)
camLockBtn.Position = UDim2.new(0.06, 120, 0.8, 0)
camLockBtn.Text = "CAM LOCK"
camLockBtn.BackgroundColor3 = Color3.fromRGB(206, 137, 36)
camLockBtn.TextColor3 = Color3.new(1, 1, 1)
camLockBtn.Font = Enum.Font.GothamBold
camLockBtn.TextSize = 16
camLockBtn.Active = true
camLockBtn.Parent = gui

local camCorner = Instance.new("UICorner")
camCorner.CornerRadius = UDim.new(0, 8)
camCorner.Parent = camLockBtn

-- Dragging (same as before)
local dragging, dragInput, dragStart, startPos
local function updateDrag(input)
	local delta = input.Position - dragStart
	charLockBtn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
		startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	camLockBtn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X + 120,
		startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

charLockBtn.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = charLockBtn.Position
		dragInput = input
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)

camLockBtn.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = charLockBtn.Position
		dragInput = input
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and input == dragInput then updateDrag(input) end
end)

-- Lock logic (same as before)
local MAX_DIST = 100
local charLockTarget, camLockTarget
local lockBillboard

local function detachBillboard()
	if lockBillboard then
		lockBillboard:Destroy()
		lockBillboard = nil
	end
end

local function attachBillboard(model, color)
	detachBillboard()
	local targetHrp = model:FindFirstChild("HumanoidRootPart")
	if not targetHrp then return end
	local bb = Instance.new("BillboardGui")
	bb.Size = UDim2.new(0, 120, 0, 40)
	bb.StudsOffset = Vector3.new(0, 3.2, 0)
	bb.AlwaysOnTop = true
	bb.Parent = targetHrp
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "LOCKED"
	label.TextScaled = true
	label.Font = Enum.Font.GothamBold
	label.TextColor3 = color
	label.Parent = bb
	lockBillboard = bb
end

local function isValidTarget(model)
	if not model or not model:IsA("Model") then return false end
	local hum = model:FindFirstChildWhichIsA("Humanoid")
	local part = model:FindFirstChild("HumanoidRootPart")
	if not hum or not part or hum.Health <= 0 then return false end
	if model == character then return false end
	if Players:GetPlayerFromCharacter(model) == player then return false end
	return true
end

local function getNearestTarget()
	if not hrp then return end
	local nearest, dist = nil, MAX_DIST
	for _, pl in ipairs(Players:GetPlayers()) do
		if pl ~= player and pl.Character and isValidTarget(pl.Character) then
			local d = (hrp.Position - pl.Character.HumanoidRootPart.Position).Magnitude
			if d < dist then
				dist = d
				nearest = pl.Character
			end
		end
	end
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and isValidTarget(obj) then
			local targetHrp = obj:FindFirstChild("HumanoidRootPart")
			if targetHrp then
				local d = (hrp.Position - targetHrp.Position).Magnitude
				if d < dist then
					dist = d
					nearest = obj
				end
			end
		end
	end
	return nearest
end

local function unlockChar()
	charLockTarget = nil
	if humanoid then humanoid.AutoRotate = true end
	charLockBtn.Text = "CHAR LOCK"
	charLockBtn.BackgroundColor3 = Color3.fromRGB(36, 137, 206)
	if not camLockTarget then detachBillboard() end
end

local function unlockCam()
	camLockTarget = nil
	camLockBtn.Text = "CAM LOCK"
	camLockBtn.BackgroundColor3 = Color3.fromRGB(206, 137, 36)
	if not charLockTarget then detachBillboard() end
	if camera then
		camera.CameraType = Enum.CameraType.Custom
		if humanoid then
			camera.CameraSubject = humanoid
		end
	end
end

charLockBtn.Activated:Connect(function()
	if charLockTarget then
		unlockChar()
	else
		local t = getNearestTarget()
		if t then
			charLockTarget = t
			if humanoid then humanoid.AutoRotate = false end
			attachBillboard(t, Color3.fromRGB(255, 80, 80))
			charLockBtn.Text = "UNLOCK"
			charLockBtn.BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		else
			charLockBtn.Text = "NO TARGET"
			task.delay(1, function()
				if not charLockTarget then 
					charLockBtn.Text = "CHAR LOCK" 
				end
			end)
		end
	end
end)

camLockBtn.Activated:Connect(function()
	if camLockTarget then
		unlockCam()
	else
		local t = getNearestTarget()
		if t then
			camLockTarget = t
			attachBillboard(t, Color3.fromRGB(80, 255, 80))
			camLockBtn.Text = "UNLOCK"
			camLockBtn.BackgroundColor3 = Color3.fromRGB(36, 206, 36)
		else
			camLockBtn.Text = "NO TARGET"
			task.delay(1, function()
				if not camLockTarget then 
					camLockBtn.Text = "CAM LOCK" 
				end
			end)
		end
	end
end)

spawn(function()
	while true do
		wait(0.1)
		if isDisabled then
			charDot.BackgroundColor3 = Color3.fromRGB(255, 80, 80)
		elseif isTransitioning then
			charDot.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
		else
			charDot.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
		end
	end
end)

-- ============================================
-- SMART CFRAME METHOD (CONFLICT-RESISTANT)
-- ============================================
SMOOTHNESS = 0.12  -- Default: SMOOTH
CONFLICT_MODE = "blend"  -- blend/force/auto

-- Adaptive smoothness during transitions
local currentSmoothness = SMOOTHNESS

RunService.Heartbeat:Connect(function(dt)
	if charLockTarget and hrp and humanoid and humanoid.Health > 0 then
		
		-- SMOOTH TRANSITION when disabling
		if isTransitioning then
			-- Gradually reduce influence
			currentSmoothness = math.max(currentSmoothness - 0.05, 0.01)
			
			if currentSmoothness <= 0.01 then
				-- Fully transitioned out
				return
			end
		elseif isDisabled then
			-- Fully disabled
			currentSmoothness = SMOOTHNESS -- Reset for next time
			return
		else
			-- Gradually restore full strength
			currentSmoothness = math.min(currentSmoothness + 0.02, SMOOTHNESS)
		end
		
		local targetHRP = charLockTarget:FindFirstChild("HumanoidRootPart")
		local targetHum = charLockTarget:FindFirstChildWhichIsA("Humanoid")
		
		if targetHRP and targetHum and targetHum.Health > 0 then
			-- Calculate desired look direction (Y-axis only)
			local currentPos = hrp.Position
			local targetPos = targetHRP.Position
			local lookPos = Vector3.new(targetPos.X, currentPos.Y, targetPos.Z)
			
			-- Create target CFrame
			local desiredCFrame = CFrame.new(currentPos, lookPos)
			
			-- Get current orientation
			local currentCFrame = hrp.CFrame
			
			-- NEW: Conflict detection
			if lastCFrameSet then
				local unexpectedChange = (hrp.CFrame.Position - lastCFrameSet.Position).Magnitude
				if unexpectedChange > 0.5 then -- CFrame changed unexpectedly
					conflictCounter = conflictCounter + 1
				else
					conflictCounter = math.max(0, conflictCounter - 1) -- Decay counter
				end
			end
			
			-- Adaptive behavior based on conflict mode
			local applySmoothness = currentSmoothness
			
			if conflictCounter >= CONFLICT_THRESHOLD then
				if CONFLICT_MODE == "blend" then
					-- Reduce our influence when conflict detected
					applySmoothness = applySmoothness * 0.3
				elseif CONFLICT_MODE == "force" then
					-- Force through conflicts (might be jittery)
					applySmoothness = applySmoothness
				elseif CONFLICT_MODE == "auto" then
					-- Pause during conflicts
					task.wait(0.1)
					conflictCounter = 0
					return
				end
			end
			
			-- Smooth interpolation
			local newCFrame = currentCFrame:Lerp(desiredCFrame, applySmoothness)
			
			-- Apply ONLY rotation, preserve position (physics-friendly)
			local currentPosition = hrp.Position
			local rotationOnly = CFrame.new(currentPosition) * (newCFrame - newCFrame.Position)
			
			-- Apply with safety check
			pcall(function()
				hrp.CFrame = rotationOnly
				lastCFrameSet = rotationOnly
			end)
			
		else
			unlockChar()
			lastCFrameSet = nil
			conflictCounter = 0
		end
	else
		lastCFrameSet = nil
		conflictCounter = 0
		currentSmoothness = SMOOTHNESS
	end
end)

-- Camera Lock (same as before)
local CAMERA_DISTANCE = 15
local CAMERA_HEIGHT = 3

RunService.RenderStepped:Connect(function()
	if camLockTarget and camera and hrp and humanoid then
		camera.CameraType = Enum.CameraType.Scriptable
		
		local targetHRP = camLockTarget:FindFirstChild("HumanoidRootPart")
		local targetHum = camLockTarget:FindFirstChildWhichIsA("Humanoid")
		
		if targetHRP and targetHum and targetHum.Health > 0 then
			local playerPos = hrp.Position + Vector3.new(0, CAMERA_HEIGHT, 0)
			local directionToTarget = (targetHRP.Position - playerPos).Unit
			local cameraPosition = playerPos - (directionToTarget * CAMERA_DISTANCE)
			local targetLook = CFrame.new(cameraPosition, targetHRP.Position)
			camera.CFrame = camera.CFrame:Lerp(targetLook, 0.2)
		else
			unlockCam()
		end
	end
	
	if not camLockTarget and camera.CameraType == Enum.CameraType.Scriptable then
		camera.CameraType = Enum.CameraType.Custom
		camera.CameraSubject = humanoid
	end
end)

print("Mobile Lock System [SMART CFRAME v3] loaded!")
print("âœ… CONFLICT-RESISTANT: Detects ragdoll/grab early")
print("âœ… SMOOTH TRANSITIONS: No jitter when disabled")
print("âœ… ADAPTIVE: Auto-adjusts during physics conflicts")
print("âœ… 4 profiles: SMOOTH/SNAP/BUTTER/ADAPT")
print("ðŸ’¡ Dot colors: Green=Active | Yellow=Transitioning | Red=Disabled")
